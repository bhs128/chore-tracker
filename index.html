<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/icon-16.png">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>Chore Tracker</title>

<style>
/* â”€â”€ Self-hosted Poppins font â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('fonts/poppins-400.woff2') format('woff2');
}
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url('fonts/poppins-600.woff2') format('woff2');
}
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url('fonts/poppins-700.woff2') format('woff2');
}

/* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* â”€â”€ Theme variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root {
  --bg:          #1a1a2e;
  --text:        #e0e0e0;
  --bar-bg:      #16213e;
  --bar-border:  #0f3460;
  --accent:      #3498db;
  --btn-bg:      #0f3460;
  --btn-border:  #1a3a6e;
  --btn-hover:   #1a3a6e;
  --cell-bg:     #222244;
  --head-bg:     #16213e;
  --head-text:   #aaa;
  --today-bg:    #1e2a50;
  --today-text:  #fff;
  --chip-bg:     #222244;
  --chip-sel-bg: #1a2e45;
  --input-bg:    #222244;
  --input-border:#333;
  --desc-text:   #888;
  --cycle-text:  #666;
  --sep-color:   #0f3460;
  --dialog-bg:   #1a1a2e;
  --tooltip-bg:  #222244;
  --future-bg:   #1e1e3a;
  --future-text: #555;
  --spark-sun:   rgba(255,255,255,0.12);
  --neutral-r:   58;
  --neutral-g:   68;
  --neutral-b:   80;
}

[data-theme="light"] {
  --bg:          #f0f2f5;
  --text:        #1a1a2e;
  --bar-bg:      #ffffff;
  --bar-border:  #d0d5dd;
  --accent:      #2980b9;
  --btn-bg:      #e8ecf1;
  --btn-border:  #c0c8d4;
  --btn-hover:   #d0d8e4;
  --cell-bg:     #e4e7ec;
  --head-bg:     #f7f8fa;
  --head-text:   #555;
  --today-bg:    #e0e6f0;
  --today-text:  #1a1a2e;
  --chip-bg:     #e4e7ec;
  --chip-sel-bg: #d6e8f7;
  --input-bg:    #ffffff;
  --input-border:#c0c8d4;
  --desc-text:   #777;
  --cycle-text:  #999;
  --sep-color:   #d0d5dd;
  --dialog-bg:   #ffffff;
  --tooltip-bg:  #ffffff;
  --future-bg:   #eaecf0;
  --future-text: #aaa;
  --spark-sun:   rgba(0,0,0,0.08);
  --neutral-r:   200;
  --neutral-g:   200;
  --neutral-b:   210;
}

html, body {
  height: 100%; width: 100%;
  overflow: hidden;
  font-family: 'Poppins', system-ui, -apple-system, sans-serif;
  background: var(--bg); color: var(--text);
  touch-action: manipulation;
  -webkit-user-select: none; user-select: none;
}

/* â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#app {
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto 1fr;
  height: 100vh; width: 100vw;
  gap: 0;
}
#top-bar {
  display: flex; align-items: center; gap: 12px;
  padding: 8px 14px;
  background: var(--bar-bg);
  border-bottom: 1px solid var(--bar-border);
  min-height: 48px;
  flex-wrap: nowrap;
  overflow: hidden;
}
#top-bar h1 { font-size: 1.4rem; font-weight: 700; color: var(--accent); letter-spacing: .5px; white-space: nowrap; }
#top-bar .actions { display: flex; gap: 6px; flex-shrink: 0; }
#top-bar button, dialog button {
  background: var(--btn-bg); color: var(--text); border: 1px solid var(--btn-border);
  padding: 8px 12px; border-radius: 6px; font-size: .78rem; cursor: pointer;
  transition: background .15s; white-space: nowrap; min-height: 38px;
}
#top-bar button:hover, dialog button:hover { background: var(--btn-hover); }

/* â”€â”€ Top-bar sections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tb-sep { width: 1px; height: 28px; background: var(--sep-color); flex-shrink: 0; }
#user-section { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
#user-section .label { font-size: .7rem; color: var(--desc-text); white-space: nowrap; }
#history-section {
  display: flex; align-items: center; gap: 6px;
  flex: 1; min-width: 0;
}
#history-section .label { font-size: .7rem; color: var(--desc-text); white-space: nowrap; }
#history-summary { font-size: .68rem; color: var(--head-text); white-space: nowrap; flex-shrink: 0; }
button.danger { background: #7a1a1a; border-color: #a33; color: #fff; }
button.danger:hover { background: #a33; }
button.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
button.primary:hover { opacity: .85; }

/* â”€â”€ Main Table Area â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#table-area {
  overflow: auto;
  padding: 10px;
}
#chore-table {
  border-collapse: separate;
  border-spacing: 2px;
  width: 100%;
  table-layout: fixed;
}
#chore-table th, #chore-table td {
  text-align: center; padding: 6px 4px;
  border-radius: 4px; font-size: .8rem;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
#chore-table thead th {
  background: var(--head-bg); color: var(--head-text); font-weight: 600;
  position: sticky; top: 0; z-index: 2;
}
#chore-table thead th.today { color: var(--today-text); background: var(--today-bg); font-weight: 700; }
.date-br { display: block; font-size: 0; height: 0; }
#chore-table .col-today { box-shadow: inset 0 0 0 2px rgba(52,152,219,0.45); }
#chore-table tbody th {
  background: var(--head-bg); text-align: left; padding-left: 10px;
  position: sticky; left: 0; z-index: 1; min-width: 240px; max-width: 300px;
  cursor: pointer;
}
#chore-table tbody th .room-name { font-weight: 600; font-size: .85rem; }
#chore-table tbody th .room-desc { font-weight: 400; font-size: .7rem; color: var(--desc-text); display: block; }
#chore-table tbody th .room-cycle { font-weight: 400; font-size: .65rem; color: var(--cycle-text); display: block; }

/* â”€â”€ Cell States â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#chore-table td {
  cursor: pointer; transition: background .12s, transform .1s;
  min-width: 44px;           /* touch-friendly minimum */
  height: 44px;
  font-weight: 600; font-size: .75rem;
}
#chore-table td:active { transform: scale(.92); }
#chore-table tbody td:not([data-action]):active { transform: none; }
td.cell-future  { background: var(--future-bg); color: var(--future-text); }

/* â”€â”€ Footer summary row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#chore-table tfoot td {
  font-size: .68rem; font-weight: 600; color: var(--head-text);
  background: var(--head-bg); cursor: default; height: auto; min-width: 0;
  position: sticky; bottom: 0; z-index: 2;
}
#chore-table tfoot td:active { transform: none; }
#chore-table tfoot th {
  background: var(--head-bg); text-align: left; padding-left: 10px;
  font-size: .7rem; font-weight: 600; color: var(--head-text);
  position: sticky; left: 0; bottom: 0; z-index: 3;
}
/* Progress row (done/due) â€” colors set inline from palette */
.foot-net-zero { opacity: .5; }

/* â”€â”€ Row sort animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#chore-table tbody tr {
  transition: transform .45s cubic-bezier(.4,0,.2,1);
}

/* â”€â”€ User chips (top bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#user-list {
  display: flex; gap: 4px; align-items: center;
}
.user-chip {
  padding: 6px 12px; border-radius: 14px;
  background: var(--chip-bg); font-size: .78rem; cursor: pointer;
  border: 2px solid transparent; transition: all .15s;
  white-space: nowrap; min-height: 34px; display: inline-flex; align-items: center;
}
.user-chip.selected { border-color: var(--accent); background: var(--chip-sel-bg); color: var(--text); }
/* user management in settings */
#settings-user-list {
  display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;
}
#settings-user-list .user-chip {
  padding: 4px 10px; border-radius: 14px;
  background: var(--chip-bg); font-size: .78rem; cursor: default;
  border: 1px solid var(--input-border);
}
#settings-user-list .remove-user {
  margin-left: 4px; color: var(--accent); font-size: .7rem; cursor: pointer;
  font-weight: 700;
}
#add-user-settings {
  display: flex; gap: 4px; margin-top: 6px;
}
#add-user-settings input {
  flex: 1; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text);
  padding: 5px 8px; border-radius: 6px; font-size: .82rem;
}

/* â”€â”€ Sparkline history (top bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#history-chart {
  height: 28px; flex: 1; min-width: 60px; max-width: 220px;
}

/* â”€â”€ Dialogs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
dialog {
  background: var(--dialog-bg); color: var(--text); border: 1px solid var(--bar-border);
  border-radius: 10px; padding: 20px 24px; max-width: 420px; width: 90%;
  position: fixed; top: 5vh; left: 50%; transform: translateX(-50%);
  margin: 0; max-height: 60vh; overflow-y: auto;
}
dialog::backdrop { background: rgba(0,0,0,.6); }
dialog h3 { margin-bottom: 12px; color: var(--accent); }
dialog label { display: block; margin: 8px 0 2px; font-size: .8rem; color: var(--head-text); }
dialog input, dialog textarea, dialog select {
  width: 100%; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text);
  padding: 6px 10px; border-radius: 6px; font-size: .85rem;
}
dialog textarea { resize: vertical; min-height: 40px; }
dialog .dialog-actions { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }

/* â”€â”€ Tooltip (cell info) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#cell-tooltip {
  display: none; position: fixed; background: var(--tooltip-bg); color: var(--text);
  border: 1px solid var(--bar-border); border-radius: 8px; padding: 8px 12px;
  font-size: .75rem; z-index: 100; pointer-events: none; max-width: 200px;
}

/* â”€â”€ Sync status indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#sync-status {
  display: none; flex-shrink: 0; align-items: center; gap: 4px;
  font-size: .65rem; color: var(--desc-text); white-space: nowrap; cursor: default;
}
#sync-status.visible { display: flex; }
#sync-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: #888; transition: background .3s;
}
#sync-dot.connected    { background: #2ecc71; }
#sync-dot.disconnected { background: #e74c3c; }
#sync-dot.syncing      { background: #f1c40f; }

/* â”€â”€ Responsive tweaks for smaller tablets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 900px) {
  #chore-table th, #chore-table td { font-size: .7rem; padding: 4px 2px; min-width: 36px; height: 36px; }
  #history-section { display: none; }
}
@media (max-width: 600px) {
  #top-bar { flex-wrap: wrap; gap: 6px; }
}

/* â”€â”€ Phone layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 480px) {
  #top-bar {
    flex-wrap: wrap; gap: 4px 8px; padding: 6px 8px; min-height: 44px;
  }
  #top-bar h1 { font-size: .95rem; }
  #top-bar h1 img { width: 16px; height: 16px; }
  #top-bar button { padding: 6px 8px; font-size: .7rem; min-height: 34px; }
  #top-bar .tb-sep { display: none; }
  #history-section { display: none; }
  #sync-status #sync-label { display: none; }
  #sync-status { flex-shrink: 0; margin-left: auto; }
  .view-toggle button { font-size: .65rem; padding: 5px 8px; min-height: 34px; }
  #user-section .user-chip { font-size: .68rem; padding: 2px 6px; }

  #chore-table tbody th {
    min-width: 110px; max-width: 150px; padding-left: 6px;
  }
  #chore-table tbody th .room-name { font-size: .72rem; }
  #chore-table tbody th .room-desc { display: none; }
  #chore-table tbody th .room-cycle { font-size: .58rem; }
  #chore-table th, #chore-table td {
    font-size: .65rem; padding: 3px 2px; min-width: 32px; height: 36px;
  }
  #chore-table tbody td[data-action="drill"]::after  { font-size: .7rem; }
  #chore-table tbody td[data-action="toggle"]::after { font-size: .85rem; }
  #chore-table tbody td[data-action="undo"]::after   { font-size: .7rem; }
  td.cell-aggregate { font-size: .58rem; }

  #back-bar { padding: 6px 8px; gap: 8px; }
  #back-bar button { font-size: .7rem; padding: 4px 8px; min-height: 36px; }
  #back-bar .breadcrumb { font-size: .75rem; }

  dialog { padding: 14px 12px; }
}

/* â”€â”€ View Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.view-toggle {
  display: flex; gap: 0; flex-shrink: 0;
}
.view-toggle button {
  border-radius: 0; border-right-width: 0;
  font-size: .72rem; padding: 4px 10px;
}
.view-toggle button:first-child { border-radius: 6px 0 0 6px; }
.view-toggle button:last-child { border-radius: 0 6px 6px 0; border-right-width: 1px; }
.view-toggle button.active {
  background: var(--accent); border-color: var(--accent); color: #fff;
}

/* â”€â”€ Back Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#back-bar {
  display: none; align-items: center; gap: 12px;
  padding: 10px 14px;
  background: var(--bar-bg);
  border-bottom: 1px solid var(--bar-border);
  font-size: .8rem;
}
#back-bar.visible { display: flex; }
#back-bar button {
  background: var(--btn-bg); color: var(--text); border: 1px solid var(--btn-border);
  padding: 8px 16px; border-radius: 6px; font-size: .9rem; cursor: pointer;
  min-height: 44px;
}
#back-bar .breadcrumb { color: var(--head-text); font-size: 1rem; }
#back-bar .breadcrumb strong { color: var(--text); font-size: 1.1rem; }

/* â”€â”€ Task Management in Room Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#task-section { margin-top: 8px; }
#task-section .task-header {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 4px;
}
#task-section .task-header label { margin: 0; }
#task-list { display: flex; flex-direction: column; gap: 4px; max-height: 150px; overflow-y: auto; }
.task-item {
  display: flex; align-items: center; gap: 6px;
  background: var(--cell-bg); padding: 4px 8px; border-radius: 6px;
}
.task-item input[type="text"] { flex: 1; min-width: 0; width: auto; }
.task-item input[type="number"] { width: 60px; flex-shrink: 0; }
.task-item .remove-task {
  cursor: pointer; font-size: .8rem; font-weight: 700;
  background: none; border: none; padding: 2px 4px; color: var(--text);
}
.no-tasks-placeholder {
  font-size: .75rem; color: var(--desc-text); font-style: italic;
  padding: 6px 0; text-align: center;
}
#add-task-row {
  display: flex; gap: 4px; margin-top: 8px;
  padding-top: 8px; border-top: 1px solid var(--sep-color);
}
#add-task-row input[type="text"] { flex: 1; min-width: 0; width: auto; }
#add-task-row input[type="number"] { width: 60px; flex-shrink: 0; }

/* â”€â”€ Aggregate cell styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
td.cell-aggregate { font-size: .65rem; font-weight: 700; }
/* Cell action hint icons */
#chore-table tbody td[data-action]  { position: relative; }
#chore-table tbody td[data-action="drill"]::after  { content: '\1F50D'; position: absolute; bottom: 3px; right: 4px; font-size: 1rem; opacity: .35; pointer-events: none; line-height: 1; }
#chore-table tbody td[data-action="toggle"]::after { content: '\2610'; position: absolute; bottom: 2px; right: 3px; font-size: 1.2rem; opacity: .3; pointer-events: none; line-height: 1; }
#chore-table tbody td[data-action="undo"]::after   { content: '\21A9'; position: absolute; bottom: 2px; right: 3px; font-size: 1rem; opacity: .3; pointer-events: none; line-height: 1; }
#chore-table tbody td[data-action] { cursor: pointer; }
#chore-table tbody td:not([data-action]) { cursor: default; }

/* â”€â”€ Drill-down parent row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#chore-table tbody tr.drill-parent th {
  background: var(--today-bg);
}

/* â”€â”€ Room Manager Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#room-manager-dialog { max-width: 480px; }
#room-manager-list {
  display: flex; flex-direction: column; gap: 4px;
  max-height: 300px; overflow-y: auto; margin-bottom: 8px;
}
.rm-item {
  display: flex; align-items: center; gap: 8px;
  background: var(--cell-bg); padding: 6px 10px; border-radius: 6px;
  cursor: pointer; transition: background .12s;
}
.rm-item:hover { background: var(--btn-hover); }
.rm-item .rm-name { flex: 1; font-size: .85rem; font-weight: 600; }
.rm-item .rm-info { font-size: .68rem; color: var(--desc-text); flex-shrink: 0; }
</style>
</head>
<body>

<div id="app">
  <!-- Top Bar -->
  <header id="top-bar">
    <h1><img src="icons/icon-32.png" alt="" width="24" height="24" style="vertical-align:-3px;margin-right:6px">Chore Tracker</h1>

    <div class="tb-sep"></div>

    <!-- User selector -->
    <div id="user-section">
      <span class="label">ğŸ‘¤</span>
      <div id="user-list"></div>
    </div>

    <div class="tb-sep"></div>

    <!-- View Toggle -->
    <div class="view-toggle">
      <button id="btn-view-room" class="active">ğŸ  Rooms</button>
      <button id="btn-view-task">ğŸ“‹ Tasks</button>
    </div>

    <div class="tb-sep"></div>

    <!-- Sparkline history -->
    <div id="history-section">
      <span class="label" id="history-label">30-day History</span>
      <canvas id="history-chart"></canvas>
      <div id="history-summary"></div>
    </div>

    <div class="tb-sep"></div>

    <!-- Sync status -->
    <div id="sync-status">
      <span id="sync-dot"></span>
      <span id="sync-label">Offline</span>
    </div>

    <div class="actions">
      <button id="btn-add-room">âœ Rooms</button>
      <button id="btn-settings">âš™</button>
    </div>
  </header>

  <!-- Drill-down back bar -->
  <div id="back-bar">
    <button id="btn-back">â† Back</button>
    <span class="breadcrumb" id="breadcrumb"></span>
    <span style="flex:1"></span>
    <button id="btn-drilldown-edit" style="display:none">âœ Edit</button>
  </div>

  <!-- Main Table -->
  <section id="table-area">
    <table id="chore-table">
      <thead id="table-head"></thead>
      <tbody id="table-body"></tbody>
      <tfoot id="table-foot"></tfoot>
    </table>
  </section>
</div>

<!-- Cell tooltip -->
<div id="cell-tooltip"></div>

<!-- Room Manager dialog -->
<dialog id="room-manager-dialog">
  <h3>Manage Rooms</h3>
  <div id="room-manager-list"></div>
  <div class="dialog-actions">
    <button id="rm-add-room" class="primary">+ New Room</button>
    <span style="flex:1"></span>
    <button id="rm-close">Close</button>
  </div>
</dialog>

<!-- Room dialog -->
<dialog id="room-dialog">
  <h3 id="room-dialog-title">Add Room</h3>
  <label for="room-name">Room Name</label>
  <input id="room-name" placeholder="e.g. Kitchen" maxlength="30">
  <label for="room-desc">Description</label>
  <textarea id="room-desc" placeholder="e.g. Wipe counters, sweep floor" maxlength="100"></textarea>
  <label for="room-days">Stays clean for (days)</label>
  <input id="room-days" type="number" min="1" max="30" value="3">
  <div id="task-section">
    <div class="task-header">
      <label>Tasks (optional)</label>
    </div>
    <div id="task-list"></div>
    <div id="add-task-row">
      <input id="new-task-label" type="text" placeholder="Add taskâ€¦" maxlength="30" list="task-suggestions">
      <input id="new-task-days" type="number" min="1" max="30" value="3" title="Clean cycle (days)">
      <button id="btn-add-task" type="button">+</button>
      <datalist id="task-suggestions"></datalist>
    </div>
  </div>
  <div class="dialog-actions">
    <button id="room-delete" class="danger" style="display:none">Delete</button>
    <span style="flex:1"></span>
    <button id="room-cancel">Cancel</button>
    <button id="room-save" class="primary">Save</button>
  </div>
</dialog>

<!-- Settings dialog -->
<dialog id="settings-dialog">
  <h3>Settings</h3>
  <label style="margin-bottom:2px">Days shown in table</label>
  <div style="display:flex;gap:10px;align-items:center">
    <div style="flex:1">
      <label for="settings-past-days" style="font-size:.75rem;color:var(--desc-text)">Past</label>
      <input id="settings-past-days" type="number" min="0" max="30" value="3">
    </div>
    <div style="flex:1">
      <label for="settings-future-days" style="font-size:.75rem;color:var(--desc-text)">Future</label>
      <input id="settings-future-days" type="number" min="1" max="60" value="10">
    </div>
  </div>
  <label for="settings-history-days">History chart days</label>
  <input id="settings-history-days" type="number" min="7" max="90" value="30">
  <label for="settings-theme">Color theme</label>
  <select id="settings-theme">
    <option value="dark">Dark</option>
    <option value="light">Light</option>
  </select>
  <label for="settings-palette">Cell color palette</label>
  <select id="settings-palette">
    <option value="blue-brown">Blue â†’ Brown (default)</option>
    <option value="green-red">Green â†’ Red</option>
    <option value="teal-purple">Teal â†’ Purple</option>
  </select>
  <label for="settings-api-url">Sync server URL <span style="font-weight:400;color:var(--desc-text)">(optional)</span></label>
  <input id="settings-api-url" type="url" placeholder="e.g. http://192.168.1.50:8780" style="font-size:.78rem">
  <div style="font-size:.68rem;color:var(--desc-text);margin-top:2px">Leave blank to auto-detect. When served from <code>server.py</code>, sync uses the current origin automatically. Set a URL to override, or open as a local file for offline-only mode.</div>
  <label>Users</label>
  <div id="settings-user-list"></div>
  <div id="add-user-settings">
    <input id="new-user-input" placeholder="Add userâ€¦" maxlength="20">
    <button id="btn-add-user">+</button>
  </div>
  <div class="dialog-actions">
    <button id="settings-export">Export JSON</button>
    <button id="settings-import">Import JSON</button>
    <input type="file" id="settings-import-file" accept=".json" style="display:none">
    <button id="settings-reset" class="danger">Reset All</button>
    <span style="flex:1"></span>
    <button id="settings-close">Close</button>
    <button id="settings-save" class="primary">Save</button>
  </div>
  <div id="settings-version" style="display:flex;align-items:center;justify-content:flex-end;gap:8px;font-size:.62rem;color:var(--desc-text);margin-top:6px;font-family:monospace">
    <span id="settings-version-text"></span>
    <button id="settings-check-update" style="font-size:.62rem;padding:2px 8px;cursor:pointer">Check for updates</button>
  </div>
</dialog>

<script>
/* ================================================================
   Chore Tracker â€” Pure vanilla JS, all data in localStorage
   ================================================================ */

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const dateStr = d => { const y = d.getFullYear(); const m = String(d.getMonth()+1).padStart(2,'0'); const day = String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; };
const today = () => dateStr(new Date());
const addDays = (iso, n) => { const d = new Date(iso + 'T12:00:00'); d.setDate(d.getDate() + n); return dateStr(d); };
const dayLabel = iso => { const d = new Date(iso + 'T12:00:00'); const wd = d.toLocaleDateString(undefined, { weekday: 'short' }); return `${wd} ${d.getMonth()+1}/${d.getDate()}`; };
const dayLabelHtml = iso => { const d = new Date(iso + 'T12:00:00'); const wd = d.toLocaleDateString(undefined, { weekday: 'short' }); return `${wd}<span class="date-br"> </span>${d.getMonth()+1}/${d.getDate()}`; };
const uid = () => crypto.randomUUID?.() || Math.random().toString(36).slice(2, 10);

// â”€â”€ Data Model (persisted to localStorage) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STORAGE_KEY = 'chore-tracker-data';

function defaultData() {
  const t = (label, cleanDays) => ({ id: uid(), label, cleanDays });
  return {
    rooms: [
      { id: uid(), name: 'Main Bathroom', desc: '', cleanDays: 7, tasks: [
        t('Wash Mirror',7), t('Fill Soap',14), t('Wash Counter',14), t('Sweep/Mop',30),
        t('Vacuum',14), t('Pickup/Tidy',7), t('Clean Toilet Bowl',30),
        t('Replace Towels/Mats',14), t('Empty Trash/Recycling',14)
      ]},
      { id: uid(), name: 'Upstairs Bathroom', desc: '', cleanDays: 7, tasks: [
        t('Wash Mirror',7), t('Fill Soap',14), t('Wash Counter',14), t('Sweep/Mop',30),
        t('Vacuum',14), t('Pickup/Tidy',7), t('Clean Toilet Bowl',30),
        t('Replace Towels/Mats',14), t('Empty Trash/Recycling',14), t('Wash Tub/Shower',30)
      ]},
      { id: uid(), name: 'Kitchen', desc: '', cleanDays: 1, tasks: [
        t('Fill Soap',14), t('Wash Counter',14), t('Sweep/Mop',30),
        t('Pickup/Tidy',7), t('Replace Towels/Mats',14),
        t('Empty Trash/Recycling',3), t('Do Dishes',1)
      ]},
      { id: uid(), name: 'Dining Room', desc: '', cleanDays: 7, tasks: [
        t('Vacuum',14), t('Pickup/Tidy',7)
      ]},
      { id: uid(), name: 'Living Room', desc: '', cleanDays: 7, tasks: [
        t('Vacuum',14), t('Pickup/Tidy',7)
      ]},
      { id: uid(), name: 'Den/Music Room', desc: '', cleanDays: 7, tasks: [
        t('Vacuum',14), t('Pickup/Tidy',7)
      ]},
      { id: uid(), name: 'Kids Bedroom', desc: '', cleanDays: 7, tasks: [
        t('Vacuum',14), t('Pickup/Tidy',7)
      ]},
      { id: uid(), name: 'Mom & Dads Room', desc: '', cleanDays: 7, tasks: [
        t('Vacuum',14), t('Pickup/Tidy',7)
      ]},
      { id: uid(), name: 'Laundry Room', desc: '', cleanDays: 1, tasks: [
        t('Fill Soap',30), t('Pickup/Tidy',7),
        t('Empty Trash/Recycling',14), t('Do Laundry',1)
      ]},
      { id: uid(), name: 'Office', desc: '', cleanDays: 7, tasks: [
        t('Pickup/Tidy',7), t('Empty Trash/Recycling',14)
      ]},
    ],
    users: [],
    entries: {},
    settings: { pastDays: 3, futureDays: 10, historyDays: 30 },
    selectedUser: null,
  };
}

let DATA;
let _syncPending = false;
let _syncDirty = false;
let _syncReady = false;  // true after first successful pull; prevents pushing stale/default data
let _ws = null;

function migrateData() {
  if (!DATA || !DATA.rooms) DATA = defaultData();
  if (!DATA.settings) DATA.settings = { pastDays: 3, futureDays: 10, historyDays: 30 };
  // Migrate old daysShown to pastDays/futureDays
  if (DATA.settings.daysShown && DATA.settings.pastDays == null) {
    DATA.settings.pastDays = 3;
    DATA.settings.futureDays = Math.max(1, DATA.settings.daysShown - 4);
    delete DATA.settings.daysShown;
  }
  if (DATA.settings.pastDays == null) DATA.settings.pastDays = 3;
  if (DATA.settings.futureDays == null) DATA.settings.futureDays = 10;
  for (const room of DATA.rooms) {
    if (!room.tasks) room.tasks = [];
  }
}

function load() {
  try { DATA = JSON.parse(localStorage.getItem(STORAGE_KEY)); } catch {}
  migrateData();
}

function save() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(DATA));
  syncPush();
}

// â”€â”€ Sync Layer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getApiUrl() {
  const explicit = (DATA?.settings?.apiUrl || '').replace(/\/+$/, '');
  if (explicit) return explicit;
  // Auto-detect: if served over HTTP(S), assume the sync server is the same origin
  if (location.protocol === 'http:' || location.protocol === 'https:') return location.origin;
  return '';
}

function setSyncStatus(state, label) {
  const el = $('#sync-status');
  const dot = $('#sync-dot');
  const lbl = $('#sync-label');
  if (!getApiUrl()) { el.classList.remove('visible'); return; }
  el.classList.add('visible');
  dot.className = '';
  dot.id = 'sync-dot';
  dot.classList.add(state);  // connected | disconnected | syncing
  if (label) lbl.textContent = label;
}

async function syncPull() {
  const url = getApiUrl();
  if (!url) return;
  setSyncStatus('syncing', 'Syncingâ€¦');
  try {
    const res = await fetch(url + '/data');
    if (!res.ok) throw new Error(res.status);
    const remote = await res.json();
    if (remote && remote.rooms) {
      // Preserve local-only settings (apiUrl, theme, selectedUser)
      const localApiUrl = DATA.settings?.apiUrl;
      const localTheme = DATA.settings?.theme;
      const localSelectedUser = DATA.selectedUser;
      DATA = remote;
      migrateData();
      if (localApiUrl) DATA.settings.apiUrl = localApiUrl;
      if (localTheme && !remote.settings?.theme) DATA.settings.theme = localTheme;
      if (localSelectedUser) DATA.selectedUser = localSelectedUser;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(DATA));
    }
    setSyncStatus('connected', 'Synced');
  } catch (e) {
    setSyncStatus('disconnected', 'Offline');
  }
}

function syncPush() {
  const url = getApiUrl();
  if (!url || !_syncReady) return;  // don't push until we've pulled at least once
  if (_syncPending) { _syncDirty = true; return; }  // mark dirty so we re-push after current flight
  _syncPending = true;
  _syncDirty = false;
  setSyncStatus('syncing', 'Savingâ€¦');
  // Strip local-only fields before sending
  const payload = JSON.parse(JSON.stringify(DATA));
  delete payload.selectedUser;  // per-device preference
  fetch(url + '/data', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  }).then(res => {
    _syncPending = false;
    if (res.ok) {
      return res.json().then(data => {
        // Update local version so we ignore our own WS broadcast
        if (data && data.version) DATA._version = data.version;
        setSyncStatus('connected', 'Synced');
        // If changes accumulated during this push, push again
        if (_syncDirty) syncPush();
      });
    } else {
      setSyncStatus('disconnected', 'Sync error');
      if (_syncDirty) syncPush();
    }
  }).catch(() => {
    _syncPending = false;
    setSyncStatus('disconnected', 'Offline');
  });
}

// â”€â”€ WebSocket (real-time push from server) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function connectWebSocket() {
  const url = getApiUrl();
  if (!url) { if (_ws) { _ws.close(); _ws = null; } return; }
  if (_ws) return;  // already connected
  // WS runs on REST port + 1
  const parsed = new URL(url);
  const wsPort = parseInt(parsed.port || (parsed.protocol === 'https:' ? 443 : 80)) + 1;
  const wsUrl = 'ws://' + parsed.hostname + ':' + wsPort;
  try {
    const ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      _ws = ws;
      setSyncStatus('connected', 'Live');
    };
    ws.onmessage = async (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        if (msg.type === 'data-changed' && msg.version !== DATA._version) {
          await syncPull();
          renderTable(); renderUsers(); renderHistory();
        }
      } catch {}
    };
    ws.onclose = () => {
      _ws = null;
      if (getApiUrl()) {
        setSyncStatus('disconnected', 'Reconnectingâ€¦');
        setTimeout(connectWebSocket, 5000);
      }
    };
    ws.onerror = () => { ws.close(); };
  } catch {
    _ws = null;
    setTimeout(connectWebSocket, 5000);
  }
}

async function syncInit() {
  if (!getApiUrl()) return;
  await syncPull();
  _syncReady = true;
  connectWebSocket();
}

// â”€â”€ View State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let viewMode = 'room';      // 'room' | 'tasktype'
let drillDown = null;        // null | { type:'room', roomId } | { type:'tasktype', taskLabel }
let drillDownOrder = null;   // cached sort order for drill-down (prevents re-sort on toggle)

// â”€â”€ Task Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function roomHasTasks(room) { return room.tasks && room.tasks.length > 0; }

function getAllTaskTypes() {
  const map = {};
  for (const room of DATA.rooms) {
    if (!roomHasTasks(room)) continue;
    for (const task of room.tasks) {
      if (!map[task.label]) map[task.label] = { label: task.label, rooms: [] };
      map[task.label].rooms.push({ roomId: room.id, roomName: room.name, taskId: task.id, cleanDays: task.cleanDays });
    }
  }
  return Object.values(map);
}

function getRoomsForTaskType(label) {
  const result = [];
  for (const room of DATA.rooms) {
    if (!roomHasTasks(room)) continue;
    const task = room.tasks.find(t => t.label === label);
    if (task) result.push({ room, task });
  }
  return result;
}

// â”€â”€ Date Range â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function visibleDates() {
  let pastDays = DATA.settings.pastDays ?? 3;
  let futureDays = DATA.settings.futureDays ?? 10;
  // Auto-clamp for phone-sized screens
  if (window.innerWidth <= 480) {
    pastDays = Math.min(pastDays, 1);
    futureDays = Math.min(futureDays, 2);
  }
  const t = today();
  const dates = [];
  for (let i = -pastDays; i <= futureDays; i++) dates.push(addDays(t, i));
  return dates;
}

// â”€â”€ Cell State Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Simple room cell info (rooms without tasks â€” original behavior)
function cellInfo(room, date) {
  const t = today();
  if (date > t) return cellInfoFuture(room, date);
  const entry = DATA.entries[date]?.[room.id];
  if (entry?.cleaned) return { state: 'cleaned', daysSince: 0, daysOverdue: 0, ratio: 0 };
  for (let i = 1; i <= 120; i++) {
    const prev = addDays(date, -i);
    if (DATA.entries[prev]?.[room.id]?.cleaned) {
      const daysSince = i;
      const daysOverdue = daysSince - room.cleanDays;
      return { state: daysOverdue >= 0 ? 'overdue' : 'clean', daysSince, daysOverdue: Math.max(0, daysOverdue), ratio: daysSince / room.cleanDays };
    }
  }
  return { state: 'overdue', daysSince: 999, daysOverdue: 999, ratio: 3 };
}

function cellInfoFuture(room, date) {
  const t = today();
  const daysFromToday = Math.round((new Date(date + 'T12:00:00') - new Date(t + 'T12:00:00')) / 86400000);
  for (let i = 0; i <= 120; i++) {
    const prev = addDays(t, -i);
    if (DATA.entries[prev]?.[room.id]?.cleaned) {
      const daysSince = i + daysFromToday;
      const daysOverdue = daysSince - room.cleanDays;
      return { state: daysOverdue >= 0 ? 'overdue' : 'clean', daysSince, daysOverdue: Math.max(0, daysOverdue), ratio: daysSince / room.cleanDays, future: true };
    }
  }
  return { state: 'overdue', daysSince: 999, daysOverdue: 999, ratio: 3, future: true };
}

// Task-level cell info (specific room+task combination)
function taskCellInfo(room, task, date) {
  const t = today();
  if (date > t) return taskCellInfoFuture(room, task, date);
  const entry = DATA.entries[date]?.[room.id]?.tasks?.[task.id];
  if (entry?.cleaned) return { state: 'cleaned', daysSince: 0, daysOverdue: 0, ratio: 0 };
  for (let i = 1; i <= 120; i++) {
    const prev = addDays(date, -i);
    if (DATA.entries[prev]?.[room.id]?.tasks?.[task.id]?.cleaned) {
      const daysSince = i;
      const daysOverdue = daysSince - task.cleanDays;
      return { state: daysOverdue >= 0 ? 'overdue' : 'clean', daysSince, daysOverdue: Math.max(0, daysOverdue), ratio: daysSince / task.cleanDays };
    }
  }
  return { state: 'overdue', daysSince: 999, daysOverdue: 999, ratio: 3 };
}

function taskCellInfoFuture(room, task, date) {
  const t = today();
  const daysFromToday = Math.round((new Date(date + 'T12:00:00') - new Date(t + 'T12:00:00')) / 86400000);
  for (let i = 0; i <= 120; i++) {
    const prev = addDays(t, -i);
    if (DATA.entries[prev]?.[room.id]?.tasks?.[task.id]?.cleaned) {
      const daysSince = i + daysFromToday;
      const daysOverdue = daysSince - task.cleanDays;
      return { state: daysOverdue >= 0 ? 'overdue' : 'clean', daysSince, daysOverdue: Math.max(0, daysOverdue), ratio: daysSince / task.cleanDays, future: true };
    }
  }
  return { state: 'overdue', daysSince: 999, daysOverdue: 999, ratio: 3, future: true };
}

// Room aggregate cell info (across its tasks)
function roomAggCellInfo(room, date) {
  if (!roomHasTasks(room)) return cellInfo(room, date);
  const total = room.tasks.length;
  let cleanCount = 0, worstRatio = 0, anyFuture = date > today();
  const ratios = [];
  for (const task of room.tasks) {
    const info = taskCellInfo(room, task, date);
    ratios.push(info.ratio);
    if (info.ratio < 1 || info.state === 'cleaned') cleanCount++;
    worstRatio = Math.max(worstRatio, info.ratio);
  }
  return { state: cleanCount === total ? 'clean' : 'overdue', cleaned: cleanCount, total, ratio: worstRatio, ratios, fraction: `${cleanCount}/${total}`, isAggregate: true, future: anyFuture };
}

// Task type aggregate cell info (across rooms)
function taskTypeAggCellInfo(taskLabel, date) {
  const roomTasks = getRoomsForTaskType(taskLabel);
  const total = roomTasks.length;
  let cleanCount = 0, worstRatio = 0, anyFuture = date > today();
  const ratios = [];
  for (const { room, task } of roomTasks) {
    const info = taskCellInfo(room, task, date);
    ratios.push(info.ratio);
    if (info.ratio < 1 || info.state === 'cleaned') cleanCount++;
    worstRatio = Math.max(worstRatio, info.ratio);
  }
  return { state: cleanCount === total ? 'clean' : 'overdue', cleaned: cleanCount, total, ratio: worstRatio, ratios, fraction: `${cleanCount}/${total}`, isAggregate: true, future: anyFuture };
}

// Effective cell info (aggregate or simple)
function effectiveCellInfo(room, date) {
  return roomHasTasks(room) ? roomAggCellInfo(room, date) : cellInfo(room, date);
}

function cellState(room, date) { return effectiveCellInfo(room, date).state; }
function cleanedBy(room, date) { return DATA.entries[date]?.[room.id]?.user || null; }
function taskCleanedBy(roomId, taskId, date) { return DATA.entries[date]?.[roomId]?.tasks?.[taskId]?.user || null; }

// â”€â”€ Footer progress stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// items: array of {room, task?}  (task present = task-level item, absent = simple room)
function footerStats(items, date) {
  let done = 0, newlyDue = 0;
  for (const item of items) {
    if (item.task) {
      // Task-level item
      if (DATA.entries[date]?.[item.room.id]?.tasks?.[item.task.id]?.cleaned) done++;
      // Became due: find last cleaning BEFORE this date, check if daysSince === cleanDays
      let daysSincePrior = 999;
      for (let i = 1; i <= 120; i++) {
        const prev = addDays(date, -i);
        if (DATA.entries[prev]?.[item.room.id]?.tasks?.[item.task.id]?.cleaned) {
          daysSincePrior = i; break;
        }
      }
      if (daysSincePrior === item.task.cleanDays) newlyDue++;
    } else {
      // Simple room item
      if (DATA.entries[date]?.[item.room.id]?.cleaned) done++;
      let daysSincePrior = 999;
      for (let i = 1; i <= 120; i++) {
        const prev = addDays(date, -i);
        if (DATA.entries[prev]?.[item.room.id]?.cleaned) {
          daysSincePrior = i; break;
        }
      }
      if (daysSincePrior === item.room.cleanDays) newlyDue++;
    }
  }
  return { done, newlyDue };
}

// Collect all atomic items for footer stats
function allAtomicItems() {
  const items = [];
  for (const room of DATA.rooms) {
    if (roomHasTasks(room)) {
      for (const task of room.tasks) items.push({ room, task });
    } else {
      items.push({ room });
    }
  }
  return items;
}

// Build progress row HTML
function progressRowHtml(items, dates, t) {
  const p = getPalette();
  const cleanClr = `rgb(${p.clean.join(',')})`;
  const dirtyClr = `rgb(${p.dirty.join(',')})`;
  let html = `<tr><th colspan=3 data-foot-tip="Daily progress:\ntasks completed\nvs tasks that became due">Progress</th>`;
  for (const d of dates) {
    const { done, newlyDue } = footerStats(items, d);
    const todayCls = d === t ? ' col-today' : '';
    const dLabel = d === t ? 'Today' : dayLabel(d);
    if (done === 0 && newlyDue === 0) {
      html += `<td class="${todayCls} foot-net-zero" data-foot-tip="${dLabel}\nNo tasks done or due">\u2014</td>`;
    } else {
      const net = done - newlyDue;
      let parts = [];
      if (done > 0) parts.push(`<span style="color:${cleanClr}">+${done}</span>`);
      if (newlyDue > 0) parts.push(`<span style="color:${dirtyClr}">\u2212${newlyDue}</span>`);
      const netWord = net > 0 ? 'cleaner' : net < 0 ? 'dirtier' : 'even';
      const netSign = net > 0 ? '+' : '';
      const tip = `${dLabel}\n${done} task${done !== 1 ? 's' : ''} done\n${newlyDue} new task${newlyDue !== 1 ? 's' : ''} due\nNet ${netSign}${net} (${netWord})`;
      html += `<td class="${todayCls}" data-foot-tip="${tip}">${parts.join(' / ')}</td>`;
    }
  }
  html += '</tr>';
  return html;
}

// â”€â”€ Unique user prefixes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function userPrefixes() {
  const users = DATA.users;
  const map = {};
  for (const u of users) {
    let len = 1;
    while (len < u.length && users.some(o => o !== u && o.slice(0, len).toLowerCase() === u.slice(0, len).toLowerCase())) len++;
    map[u] = u.slice(0, len).toUpperCase();
  }
  return map;
}

// â”€â”€ Color gradient helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _neutralCache = null;
function getNeutral() {
  if (_neutralCache) return _neutralCache;
  const cs = getComputedStyle(document.documentElement);
  _neutralCache = {
    r: parseInt(cs.getPropertyValue('--neutral-r')) || 58,
    g: parseInt(cs.getPropertyValue('--neutral-g')) || 68,
    b: parseInt(cs.getPropertyValue('--neutral-b')) || 80
  };
  return _neutralCache;
}
function invalidateNeutralCache() { _neutralCache = null; }

const PALETTES = {
  'green-red': {
    clean: [46, 204, 113],   // green
    dirty: [231, 76, 60],    // red
    textLight: ['#1a3a1a', '#444', '#5a1010'],
    textDark:  ['#fff', '#ccc', '#ffcccc']
  },
  'blue-brown': {
    clean: [52, 152, 219],   // blue
    dirty: [160, 82, 45],    // brown
    textLight: ['#0d2740', '#444', '#3e1a0a'],
    textDark:  ['#fff', '#ccc', '#f5dcc8']
  },
  'teal-purple': {
    clean: [26, 188, 156],   // teal
    dirty: [155, 89, 182],   // purple
    textLight: ['#0a2e26', '#444', '#2d1542'],
    textDark:  ['#fff', '#ccc', '#e8d5f0']
  }
};

function getPalette() {
  return PALETTES[DATA.settings.palette] || PALETTES['blue-brown'];
}

function cellColor(ratio, isFuture) {
  const opacity = isFuture ? 0.55 : 1;
  const n = getNeutral();
  const p = getPalette();
  if (ratio <= 0) {
    return `rgba(${p.clean[0]},${p.clean[1]},${p.clean[2]},${opacity})`;
  } else if (ratio < 1) {
    const t = ratio;
    const r = Math.round(p.clean[0] + (n.r - p.clean[0]) * t);
    const g = Math.round(p.clean[1] + (n.g - p.clean[1]) * t);
    const b = Math.round(p.clean[2] + (n.b - p.clean[2]) * t);
    return `rgba(${r},${g},${b},${opacity})`;
  } else if (ratio < 2) {
    const t = ratio - 1;
    const r = Math.round(n.r + (p.dirty[0] - n.r) * t);
    const g = Math.round(n.g + (p.dirty[1] - n.g) * t);
    const b = Math.round(n.b + (p.dirty[2] - n.b) * t);
    return `rgba(${r},${g},${b},${opacity})`;
  } else {
    return `rgba(${p.dirty[0]},${p.dirty[1]},${p.dirty[2]},${opacity})`;
  }
}

function cellTextColor(ratio) {
  const light = document.documentElement.getAttribute('data-theme') === 'light';
  const p = getPalette();
  const txt = light ? p.textLight : p.textDark;
  if (ratio < 0.6) return txt[0];
  if (ratio < 1.2) return txt[1];
  return txt[2];
}

function aggCellBg(info) {
  if (!info.isAggregate || !info.ratios || info.ratios.length <= 1)
    return cellColor(info.ratio, info.future);
  // Sort ratios so best (greenest) are on the left, worst on the right
  const sorted = [...info.ratios].sort((a, b) => a - b);
  // If all identical, just use a flat color
  if (sorted[0] === sorted[sorted.length - 1])
    return cellColor(sorted[0], info.future);
  // Build gradient with one stripe per subtask, matching drill-down colors
  const n = sorted.length;
  const stops = [];
  for (let i = 0; i < n; i++) {
    const color = cellColor(sorted[i], info.future);
    const start = Math.round((i / n) * 100);
    const end = Math.round(((i + 1) / n) * 100);
    stops.push(`${color} ${start}%, ${color} ${end}%`);
  }
  return `linear-gradient(to right, ${stops.join(', ')})`;
}

// â”€â”€ Sort â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function daysUntilDue(room) {
  if (roomHasTasks(room)) {
    let worst = Infinity;
    for (const task of room.tasks) {
      const info = taskCellInfo(room, task, today());
      const dud = task.cleanDays - (info.daysSince ?? 0);
      if (dud < worst) worst = dud;
    }
    return worst === Infinity ? -999 : worst;
  }
  const info = cellInfo(room, today());
  if (info.daysSince === 999) return -999;
  return room.cleanDays - (info.daysSince ?? 0);
}

function roomSortKey(room) {
  const info = effectiveCellInfo(room, today());
  // fraction done: 0 = nothing done, 1 = all done
  const frac = info.isAggregate ? info.cleaned / info.total : (info.state === 'cleaned' || info.ratio < 1 ? 1 : 0);
  const dud = daysUntilDue(room);
  return { frac, dud };
}

function sortedRooms() {
  return [...DATA.rooms].sort((a, b) => {
    const ka = roomSortKey(a), kb = roomSortKey(b);
    // Primary: fewer completed first (dirtiest)
    if (ka.frac !== kb.frac) return ka.frac - kb.frac;
    // Secondary: most overdue first
    if (ka.dud !== kb.dud) return ka.dud - kb.dud;
    return (a.cleanDays || 1) - (b.cleanDays || 1);
  });
}

function taskTypeSortKey(label) {
  const info = taskTypeAggCellInfo(label, today());
  const frac = info.cleaned / info.total;
  const dud = taskTypeDaysUntilDue(label);
  return { frac, dud };
}

function sortedTaskTypes() {
  return getAllTaskTypes().sort((a, b) => {
    const ka = taskTypeSortKey(a.label), kb = taskTypeSortKey(b.label);
    if (ka.frac !== kb.frac) return ka.frac - kb.frac;
    if (ka.dud !== kb.dud) return ka.dud - kb.dud;
    return 0;
  });
}

function taskTypeDaysUntilDue(taskLabel) {
  let worst = Infinity;
  for (const { room, task } of getRoomsForTaskType(taskLabel)) {
    const info = taskCellInfo(room, task, today());
    const dud = task.cleanDays - (info.daysSince ?? 0);
    if (dud < worst) worst = dud;
  }
  return worst === Infinity ? -999 : worst;
}

function sortedTasksInRoom(room) {
  if (!roomHasTasks(room)) return [];
  return [...room.tasks].sort((a, b) => {
    const da = a.cleanDays - (taskCellInfo(room, a, today()).daysSince ?? 0);
    const db = b.cleanDays - (taskCellInfo(room, b, today()).daysSince ?? 0);
    return da - db;
  });
}

function sortedRoomsForTask(taskLabel) {
  return getRoomsForTaskType(taskLabel).sort((a, b) => {
    const da = a.task.cleanDays - (taskCellInfo(a.room, a.task, today()).daysSince ?? 0);
    const db = b.task.cleanDays - (taskCellInfo(b.room, b.task, today()).daysSince ?? 0);
    return da - db;
  });
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTable(animate) {
  const dates = visibleDates();
  const t = today();
  const prefixes = userPrefixes();

  renderTableHead(dates, t);
  updateBackBar();

  if (drillDown) {
    if (!drillDownOrder) {
      // First render of this drill-down: cache the sort order
      if (drillDown.type === 'room') {
        const room = DATA.rooms.find(r => r.id === drillDown.roomId);
        drillDownOrder = room ? sortedTasksInRoom(room).map(t => t.id) : [];
      } else {
        drillDownOrder = sortedRoomsForTask(drillDown.taskLabel).map(rt => rt.room.id + ':' + rt.task.id);
      }
    }
    renderDrillDown(dates, t, prefixes);
  }
  else if (viewMode === 'room') renderRoomView(dates, t, prefixes, animate);
  else renderTaskTypeView(dates, t, prefixes);

  const todayTh = $('#table-head th.today');
  if (todayTh) todayTh.scrollIntoView({ inline: 'center', block: 'nearest' });
}

function renderTableHead(dates, t) {
  let headHtml = '<colgroup><col><col><col>';
  for (let i = 0; i < dates.length; i++) headHtml += '<col>';
  headHtml += '</colgroup><tr><th colspan=3>' + (viewMode === 'tasktype' && !drillDown ? 'Task Type' : 'Room') + '</th>';
  for (const d of dates) {
    const cls = d === t ? ' class="today"' : '';
    const label = d === t ? 'Today' : dayLabelHtml(d);
    headHtml += `<th${cls}>${label}</th>`;
  }
  headHtml += '</tr>';
  $('#table-head').innerHTML = headHtml;
}

function updateBackBar() {
  const bar = $('#back-bar');
  const bc = $('#breadcrumb');
  const editBtn = $('#btn-drilldown-edit');
  if (!drillDown) { bar.classList.remove('visible'); editBtn.style.display = 'none'; return; }
  bar.classList.add('visible');
  if (drillDown.type === 'room') {
    const room = DATA.rooms.find(r => r.id === drillDown.roomId);
    bc.innerHTML = `<strong class="breadcrumb-name" data-edit-room="${esc(drillDown.roomId)}" style="cursor:pointer;text-decoration:underline dotted;text-underline-offset:3px">${esc(room?.name || '?')}</strong> â€” tasks`;
    editBtn.style.display = '';
    editBtn.onclick = () => openRoomDialog(drillDown.roomId);
  } else {
    bc.innerHTML = `<strong>${esc(drillDown.taskLabel)}</strong> â€” rooms`;
    editBtn.style.display = 'none';
  }
}

function renderRoomView(dates, t, prefixes, animate) {
  const rooms = sortedRooms();

  // FLIP animation prep
  const oldPos = {};
  if (animate) {
    for (const tr of $('#table-body').querySelectorAll('tr[data-row-id]'))
      oldPos[tr.dataset.rowId] = tr.getBoundingClientRect().top;
  }

  let html = '';
  for (const room of rooms) {
    html += `<tr data-row-id="${room.id}" data-room-id="${room.id}">`;
    html += `<th colspan=3 data-room-id="${room.id}">
      <span class="room-name">${esc(room.name)}</span>
      <span class="room-desc">${esc(room.desc)}</span>
      <span class="room-cycle">${roomHasTasks(room) ? room.tasks.length + ' task' + (room.tasks.length > 1 ? 's' : '') : 'every ' + room.cleanDays + 'd'}</span>
    </th>`;
    for (const d of dates) {
      if (roomHasTasks(room)) {
        const info = roomAggCellInfo(room, d);
        const bg = aggCellBg(info);
        const fg = cellTextColor(info.ratio);
        const todayCls = d === t ? ' col-today' : '';
        html += `<td class="cell-aggregate${todayCls}" style="background:${bg};color:${fg}" data-room="${room.id}" data-date="${d}" data-aggregate="room" data-action="drill">${info.fraction}</td>`;
      } else {
        const info = cellInfo(room, d);
        const user = cleanedBy(room, d);
        const isFuture = !!info.future;
        const bg = cellColor(info.ratio, isFuture);
        const fg = cellTextColor(info.ratio);
        const todayCls = d === t ? ' col-today' : '';
        let label = '';
        if (info.state === 'cleaned') label = user ? (prefixes[user] || user.charAt(0).toUpperCase()) : 'âœ“';
        else if (info.daysOverdue > 0) label = `+${info.daysOverdue}`;
        const action = isFuture ? '' : info.state === 'cleaned' ? ' data-action="undo"' : ' data-action="toggle"';
        html += `<td class="${todayCls}" style="background:${bg};color:${fg}" data-room="${room.id}" data-date="${d}"${action}>${label}</td>`;
      }
    }
    html += '</tr>';
  }
  $('#table-body').innerHTML = html;

  // FLIP animation
  if (animate && Object.keys(oldPos).length > 0) {
    for (const tr of $('#table-body').querySelectorAll('tr[data-row-id]')) {
      const id = tr.dataset.rowId;
      if (id in oldPos) {
        const delta = oldPos[id] - tr.getBoundingClientRect().top;
        if (Math.abs(delta) > 1) {
          tr.style.transition = 'none';
          tr.style.transform = `translateY(${delta}px)`;
          tr.offsetHeight;
          tr.style.transition = '';
          tr.style.transform = '';
        }
      }
    }
  }

  // Footer
  let footHtml = `<tr><th colspan=3 data-foot-tip="Tasks clean out of total\nacross all rooms">Summary</th>`;
  for (const d of dates) {
    let clean = 0, total = 0;
    for (const room of rooms) {
      if (roomHasTasks(room)) {
        const info = roomAggCellInfo(room, d);
        clean += info.cleaned; total += info.total;
      } else {
        const s = cellInfo(room, d);
        if (s.state === 'cleaned' || s.state === 'clean') clean++;
        total++;
      }
    }
    const todayCls = d === t ? ' col-today' : '';
    const dLabel = d === t ? 'Today' : dayLabel(d);
    const dirty = total - clean;
    const tip = `${dLabel}\n${clean} of ${total} tasks clean\n${dirty} task${dirty !== 1 ? 's' : ''} need attention`;
    footHtml += `<td class="${todayCls}" data-foot-tip="${tip}">${clean}/${total}</td>`;
  }
  footHtml += '</tr>';
  footHtml += progressRowHtml(allAtomicItems(), dates, t);
  $('#table-foot').innerHTML = footHtml;
}

function renderTaskTypeView(dates, t, prefixes) {
  const taskTypes = sortedTaskTypes();

  let html = '';
  for (const tt of taskTypes) {
    html += `<tr data-row-id="tt-${tt.label}">`;
    html += `<th colspan=3 data-tasktype="${esc(tt.label)}">
      <span class="room-name">${esc(tt.label)}</span>
      <span class="room-desc">${tt.rooms.length} room${tt.rooms.length > 1 ? 's' : ''}</span>
    </th>`;
    for (const d of dates) {
      const info = taskTypeAggCellInfo(tt.label, d);
      const bg = aggCellBg(info);
      const fg = cellTextColor(info.ratio);
      const todayCls = d === t ? ' col-today' : '';
      const roomTasks = getRoomsForTaskType(tt.label);
      const isSingle = roomTasks.length === 1;
      const isFuture = d > t;
      let action;
      if (isSingle) {
        if (isFuture) action = '';
        else {
          const si = taskCellInfo(roomTasks[0].room, roomTasks[0].task, d);
          action = si.state === 'cleaned' ? ' data-action="undo"' : ' data-action="toggle"';
        }
      } else { action = ' data-action="drill"'; }
      html += `<td class="cell-aggregate${todayCls}" style="background:${bg};color:${fg}" data-tasktype="${esc(tt.label)}" data-date="${d}" data-aggregate="tasktype"${action}>${info.fraction}</td>`;
    }
    html += '</tr>';
  }

  if (taskTypes.length === 0) {
    html = '<tr><td colspan="100" style="text-align:center;color:var(--desc-text);padding:20px">No task types defined. Edit a room to add tasks.</td></tr>';
  }

  $('#table-body').innerHTML = html;

  // Footer
  let footHtml = `<tr><th colspan=3 data-foot-tip="Tasks clean out of total\nacross all task types">Summary</th>`;
  for (const d of dates) {
    let clean = 0, total = 0;
    for (const tt of taskTypes) {
      const info = taskTypeAggCellInfo(tt.label, d);
      clean += info.cleaned; total += info.total;
    }
    const todayCls = d === t ? ' col-today' : '';
    const dLabel = d === t ? 'Today' : dayLabel(d);
    const dirty = total - clean;
    const tip = `${dLabel}\n${clean} of ${total} tasks clean\n${dirty} task${dirty !== 1 ? 's' : ''} need attention`;
    footHtml += `<td class="${todayCls}" data-foot-tip="${tip}">${clean}/${total}</td>`;
  }
  footHtml += '</tr>';
  footHtml += progressRowHtml(allAtomicItems(), dates, t);
  $('#table-foot').innerHTML = footHtml;
}

function renderDrillDown(dates, t, prefixes) {
  let html = '';

  if (drillDown.type === 'room') {
    const room = DATA.rooms.find(r => r.id === drillDown.roomId);
    if (!room || !roomHasTasks(room)) { drillDown = null; drillDownOrder = null; renderTable(); return; }

    // Parent aggregate row
    html += `<tr class="drill-parent" data-room-id="${room.id}">
      <th colspan=3 data-room-id="${room.id}">
        <span class="room-name">${esc(room.name)}</span>
        <span class="room-desc">${esc(room.desc)}</span>
      </th>`;
    for (const d of dates) {
      const info = roomAggCellInfo(room, d);
      const bg = cellColor(info.ratio, info.future);
      const fg = cellTextColor(info.ratio);
      const todayCls = d === t ? ' col-today' : '';
      html += `<td class="${todayCls}" style="background:${bg};color:${fg}">${info.fraction}</td>`;
    }
    html += '</tr>';

    // Task detail rows (use cached order)
    const allTasks = room.tasks || [];
    const orderedTasks = drillDownOrder
      ? drillDownOrder.map(id => allTasks.find(t => t.id === id)).filter(Boolean)
      : sortedTasksInRoom(room);
    for (const task of orderedTasks) {
      html += `<tr data-room-id="${room.id}" data-task-id="${task.id}">
        <th colspan=3 data-tasktype="${esc(task.label)}">
          <span class="room-name" style="padding-left:16px">â€º ${esc(task.label)}</span>
          <span class="room-cycle">every ${task.cleanDays}d</span>
        </th>`;
      for (const d of dates) {
        const info = taskCellInfo(room, task, d);
        const user = taskCleanedBy(room.id, task.id, d);
        const isFuture = !!info.future;
        const bg = cellColor(info.ratio, isFuture);
        const fg = cellTextColor(info.ratio);
        const todayCls = d === t ? ' col-today' : '';
        let label = '';
        if (info.state === 'cleaned') label = user ? (prefixes[user] || user.charAt(0).toUpperCase()) : 'âœ“';
        else if (info.daysOverdue > 0) label = `+${info.daysOverdue}`;
        const action = isFuture ? '' : info.state === 'cleaned' ? ' data-action="undo"' : ' data-action="toggle"';
        html += `<td class="${todayCls}" style="background:${bg};color:${fg}" data-room="${room.id}" data-task="${task.id}" data-date="${d}"${action}>${label}</td>`;
      }
      html += '</tr>';
    }

  } else if (drillDown.type === 'tasktype') {
    const taskLabel = drillDown.taskLabel;

    // Room detail rows (use cached order)
    const allRoomTasks = getRoomsForTaskType(taskLabel);
    const orderedRoomTasks = drillDownOrder
      ? drillDownOrder.map(key => { const [rid, tid] = key.split(':'); return allRoomTasks.find(rt => rt.room.id === rid && rt.task.id === tid); }).filter(Boolean)
      : sortedRoomsForTask(taskLabel);
    if (orderedRoomTasks.length === 0) { drillDown = null; drillDownOrder = null; renderTable(); return; }

    // Parent aggregate row
    html += `<tr class="drill-parent">
      <th colspan=3>
        <span class="room-name">${esc(taskLabel)}</span>
        <span class="room-desc">${orderedRoomTasks.length} room${orderedRoomTasks.length > 1 ? 's' : ''}</span>
      </th>`;
    for (const d of dates) {
      const info = taskTypeAggCellInfo(taskLabel, d);
      const bg = cellColor(info.ratio, info.future);
      const fg = cellTextColor(info.ratio);
      const todayCls = d === t ? ' col-today' : '';
      html += `<td class="${todayCls}" style="background:${bg};color:${fg}">${info.fraction}</td>`;
    }
    html += '</tr>';

    for (const { room, task } of orderedRoomTasks) {
      html += `<tr data-room-id="${room.id}" data-task-id="${task.id}">
        <th colspan=3 data-room-id="${room.id}">
          <span class="room-name" style="padding-left:16px">â€º ${esc(room.name)}</span>
          <span class="room-cycle">every ${task.cleanDays}d</span>
        </th>`;
      for (const d of dates) {
        const info = taskCellInfo(room, task, d);
        const user = taskCleanedBy(room.id, task.id, d);
        const isFuture = !!info.future;
        const bg = cellColor(info.ratio, isFuture);
        const fg = cellTextColor(info.ratio);
        const todayCls = d === t ? ' col-today' : '';
        let label = '';
        if (info.state === 'cleaned') label = user ? (prefixes[user] || user.charAt(0).toUpperCase()) : 'âœ“';
        else if (info.daysOverdue > 0) label = `+${info.daysOverdue}`;
        const action = isFuture ? '' : info.state === 'cleaned' ? ' data-action="undo"' : ' data-action="toggle"';
        html += `<td class="${todayCls}" style="background:${bg};color:${fg}" data-room="${room.id}" data-task="${task.id}" data-date="${d}"${action}>${label}</td>`;
      }
      html += '</tr>';
    }
  }

  $('#table-body').innerHTML = html;

  // Footer
  const drillLabel = drillDown.type === 'room'
    ? (DATA.rooms.find(r => r.id === drillDown.roomId)?.name || 'Room')
    : (drillDown.taskLabel || 'Task');
  let footHtml = `<tr><th colspan=3 data-foot-tip="Tasks clean out of total\nin ${esc(drillLabel)}">Summary</th>`;
  const drillItems = [];
  if (drillDown.type === 'room') {
    const room = DATA.rooms.find(r => r.id === drillDown.roomId);
    if (room && roomHasTasks(room)) {
      for (const task of room.tasks) drillItems.push({ room, task });
    }
  } else {
    for (const { room, task } of getRoomsForTaskType(drillDown.taskLabel)) {
      drillItems.push({ room, task });
    }
  }
  for (const d of dates) {
    let clean = 0, total = 0;
    for (const item of drillItems) {
      const info = taskCellInfo(item.room, item.task, d);
      if (info.ratio < 1 || info.state === 'cleaned') clean++;
      total++;
    }
    const todayCls = d === t ? ' col-today' : '';
    const dLabel = d === t ? 'Today' : dayLabel(d);
    const dirty = total - clean;
    const tip = `${dLabel}\n${clean} of ${total} tasks clean\n${dirty} task${dirty !== 1 ? 's' : ''} need attention`;
    footHtml += `<td class="${todayCls}" data-foot-tip="${tip}">${clean}/${total}</td>`;
  }
  footHtml += '</tr>';
  footHtml += progressRowHtml(drillItems, dates, t);
  $('#table-foot').innerHTML = footHtml;
}

function esc(s) { const el = document.createElement('span'); el.textContent = s; return el.innerHTML; }

// â”€â”€ Cell Click â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$('#table-body').addEventListener('click', e => {
  // Task detail cell (has data-task): toggle individual task
  const tdTask = e.target.closest('td[data-room][data-task][data-date]');
  if (tdTask) {
    toggleTaskCell(tdTask.dataset.room, tdTask.dataset.task, tdTask.dataset.date);
    return;
  }

  // Aggregate cell: drill down (or auto-toggle if single room)
  const tdAgg = e.target.closest('td[data-aggregate]');
  if (tdAgg) {
    if (tdAgg.dataset.aggregate === 'room') {
      drillDownOrder = null; drillDown = { type: 'room', roomId: tdAgg.dataset.room };
    } else if (tdAgg.dataset.aggregate === 'tasktype') {
      const roomTasks = getRoomsForTaskType(tdAgg.dataset.tasktype);
      if (roomTasks.length === 1 && tdAgg.dataset.date) {
        toggleTaskCell(roomTasks[0].room.id, roomTasks[0].task.id, tdAgg.dataset.date);
        return;
      }
      drillDownOrder = null; drillDown = { type: 'tasktype', taskLabel: tdAgg.dataset.tasktype };
    }
    renderTable();
    return;
  }

  // Simple room cell (no tasks): toggle room
  const tdSimple = e.target.closest('td[data-room][data-date]');
  if (tdSimple && !tdSimple.dataset.aggregate) {
    toggleCell(tdSimple.dataset.room, tdSimple.dataset.date);
    return;
  }

  // Room header: drill down (rooms with tasks) or edit (simple rooms)
  const th = e.target.closest('th[data-room-id]');
  if (th) {
    const room = DATA.rooms.find(r => r.id === th.dataset.roomId);
    if (room && roomHasTasks(room)) {
      drillDownOrder = null; drillDown = { type: 'room', roomId: room.id };
      renderTable();
    }
    return;
  }

  // Task type header: drill down
  const thTT = e.target.closest('th[data-tasktype]');
  if (thTT) {
    drillDownOrder = null; drillDown = { type: 'tasktype', taskLabel: thTT.dataset.tasktype };
    renderTable();
    return;
  }
});

function toggleCell(roomId, date) {
  if (date > today()) return;
  if (!DATA.entries[date]) DATA.entries[date] = {};
  const existing = DATA.entries[date][roomId];
  if (existing?.cleaned) {
    delete DATA.entries[date][roomId];
  } else {
    DATA.entries[date][roomId] = { cleaned: true, user: DATA.selectedUser || '' };
  }
  save();
  renderTable(true);
  renderHistory();
}

function toggleTaskCell(roomId, taskId, date) {
  if (date > today()) return;
  if (!DATA.entries[date]) DATA.entries[date] = {};
  if (!DATA.entries[date][roomId]) DATA.entries[date][roomId] = {};
  if (!DATA.entries[date][roomId].tasks) DATA.entries[date][roomId].tasks = {};

  const existing = DATA.entries[date][roomId].tasks[taskId];
  if (existing?.cleaned) {
    delete DATA.entries[date][roomId].tasks[taskId];
    if (Object.keys(DATA.entries[date][roomId].tasks).length === 0) delete DATA.entries[date][roomId].tasks;
    if (Object.keys(DATA.entries[date][roomId]).length === 0) delete DATA.entries[date][roomId];
  } else {
    DATA.entries[date][roomId].tasks[taskId] = { cleaned: true, user: DATA.selectedUser || '' };
  }
  save();
  renderTable(true);
  renderHistory();
}

// â”€â”€ View Toggle & Back â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$('#btn-view-room').addEventListener('click', () => {
  if (viewMode === 'room' && !drillDown) return;
  viewMode = 'room'; drillDown = null; drillDownOrder = null;
  updateViewToggle(); renderTable();
});
$('#btn-view-task').addEventListener('click', () => {
  if (viewMode === 'tasktype' && !drillDown) return;
  viewMode = 'tasktype'; drillDown = null; drillDownOrder = null;
  updateViewToggle(); renderTable();
});
$('#btn-back').addEventListener('click', () => { drillDown = null; drillDownOrder = null; renderTable(); });
$('#breadcrumb').addEventListener('click', e => {
  const el = e.target.closest('[data-edit-room]');
  if (el) openRoomDialog(el.dataset.editRoom);
});

function updateViewToggle() {
  $('#btn-view-room').classList.toggle('active', viewMode === 'room');
  $('#btn-view-task').classList.toggle('active', viewMode === 'tasktype');
}

// â”€â”€ Room Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let editingRoomId = null;
let dialogTasks = [];
let _roomDialogFromManager = false;

function openRoomDialog(roomId) {
  editingRoomId = roomId || null;
  const dialog = $('#room-dialog');
  if (roomId) {
    const room = DATA.rooms.find(r => r.id === roomId);
    if (!room) return;
    $('#room-dialog-title').textContent = 'Edit Room';
    $('#room-name').value = room.name;
    $('#room-desc').value = room.desc;
    $('#room-days').value = room.cleanDays;
    $('#room-delete').style.display = '';
    dialogTasks = room.tasks ? room.tasks.map(t => ({ ...t })) : [];
  } else {
    $('#room-dialog-title').textContent = 'Add Room';
    $('#room-name').value = '';
    $('#room-desc').value = '';
    $('#room-days').value = 3;
    $('#room-delete').style.display = 'none';
    dialogTasks = [];
  }
  renderDialogTasks();
  dialog.showModal();
}

function renderDialogTasks() {
  const list = $('#task-list');
  if (dialogTasks.length === 0) {
    list.innerHTML = '<div class="no-tasks-placeholder">No tasks defined â€” room uses simple toggle</div>';
  } else {
    list.innerHTML = dialogTasks.map((t, i) =>
      `<div class="task-item" data-idx="${i}">
        <input type="text" value="${esc(t.label)}" data-field="label" placeholder="Task name" list="task-suggestions">
        <input type="number" value="${t.cleanDays}" data-field="cleanDays" min="1" max="30" title="Clean cycle (days)">
        <span style="font-size:.65rem;color:var(--cycle-text)">d</span>
        <button class="remove-task" data-idx="${i}" type="button">âœ•</button>
      </div>`
    ).join('');
  }
  updateTaskSuggestions();
}

let _taskDaysMap = {};

function updateTaskSuggestions() {
  const existing = new Set(dialogTasks.map(t => t.label.trim().toLowerCase()));
  const labelDays = {};
  for (const room of DATA.rooms) {
    if (!room.tasks) continue;
    for (const task of room.tasks) {
      const lbl = task.label.trim();
      if (!lbl || existing.has(lbl.toLowerCase())) continue;
      if (!labelDays[lbl]) labelDays[lbl] = {};
      labelDays[lbl][task.cleanDays] = (labelDays[lbl][task.cleanDays] || 0) + 1;
    }
  }
  _taskDaysMap = {};
  const labels = Object.keys(labelDays).sort();
  for (const lbl of labels) {
    const counts = labelDays[lbl];
    _taskDaysMap[lbl.toLowerCase()] = parseInt(Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0]);
  }
  $('#task-suggestions').innerHTML = labels.map(l => `<option value="${esc(l)}">`).join('');
}

// Task list event delegation
$('#task-list').addEventListener('input', e => {
  const item = e.target.closest('.task-item');
  if (!item) return;
  const idx = parseInt(item.dataset.idx);
  const field = e.target.dataset.field;
  if (field === 'label') {
    dialogTasks[idx].label = e.target.value;
    const val = e.target.value.trim().toLowerCase();
    if (val && _taskDaysMap[val] !== undefined) {
      dialogTasks[idx].cleanDays = _taskDaysMap[val];
      item.querySelector('input[data-field="cleanDays"]').value = _taskDaysMap[val];
    }
  }
  else if (field === 'cleanDays') dialogTasks[idx].cleanDays = Math.max(1, parseInt(e.target.value) || 1);
});
$('#task-list').addEventListener('click', e => {
  const btn = e.target.closest('.remove-task');
  if (btn) { dialogTasks.splice(parseInt(btn.dataset.idx), 1); renderDialogTasks(); }
});

$('#btn-add-task').addEventListener('click', () => {
  const labelInput = $('#new-task-label');
  const daysInput = $('#new-task-days');
  const label = labelInput.value.trim();
  if (!label) return;
  dialogTasks.push({ id: uid(), label, cleanDays: Math.max(1, parseInt(daysInput.value) || 3) });
  labelInput.value = '';
  daysInput.value = 3;
  renderDialogTasks();
});
$('#new-task-label').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); $('#btn-add-task').click(); } });
$('#new-task-label').addEventListener('input', () => {
  const val = $('#new-task-label').value.trim().toLowerCase();
  if (val && _taskDaysMap[val] !== undefined) $('#new-task-days').value = _taskDaysMap[val];
});

$('#btn-add-room').addEventListener('click', () => openRoomManager());
$('#rm-close').addEventListener('click', () => $('#room-manager-dialog').close());
$('#rm-add-room').addEventListener('click', () => { $('#room-manager-dialog').close(); _roomDialogFromManager = true; openRoomDialog(null); });
$('#room-manager-list').addEventListener('click', e => {
  const item = e.target.closest('.rm-item');
  if (item) { $('#room-manager-dialog').close(); _roomDialogFromManager = true; openRoomDialog(item.dataset.roomId); }
});
function openRoomManager() {
  const list = $('#room-manager-list');
  list.innerHTML = DATA.rooms.map(r => {
    const taskCount = roomHasTasks(r) ? r.tasks.length + ' task' + (r.tasks.length > 1 ? 's' : '') : 'no tasks';
    return `<div class="rm-item" data-room-id="${r.id}">
      <span class="rm-name">${esc(r.name)}</span>
      <span class="rm-info">${taskCount}</span>
    </div>`;
  }).join('') || '<div style="text-align:center;color:var(--desc-text);padding:12px">No rooms yet</div>';
  $('#room-manager-dialog').showModal();
}
$('#room-cancel').addEventListener('click', () => { $('#room-dialog').close(); if (_roomDialogFromManager) openRoomManager(); _roomDialogFromManager = false; });
$('#room-save').addEventListener('click', () => {
  const name = $('#room-name').value.trim();
  if (!name) return;
  const desc = $('#room-desc').value.trim();
  const cleanDays = Math.max(1, parseInt($('#room-days').value) || 3);
  const tasks = dialogTasks.filter(t => t.label.trim()).map(t => ({ id: t.id, label: t.label.trim(), cleanDays: t.cleanDays }));
  if (editingRoomId) {
    const room = DATA.rooms.find(r => r.id === editingRoomId);
    if (room) { room.name = name; room.desc = desc; room.cleanDays = cleanDays; room.tasks = tasks; }
  } else {
    DATA.rooms.push({ id: uid(), name, desc, cleanDays, tasks });
  }
  save(); renderTable(); renderHistory();
  $('#room-dialog').close();
  if (_roomDialogFromManager) openRoomManager();
  _roomDialogFromManager = false;
});
$('#room-delete').addEventListener('click', () => {
  if (editingRoomId && confirm('Delete this room?')) {
    DATA.rooms = DATA.rooms.filter(r => r.id !== editingRoomId);
    for (const d of Object.keys(DATA.entries)) delete DATA.entries[d]?.[editingRoomId];
    if (drillDown?.type === 'room' && drillDown.roomId === editingRoomId) { drillDown = null; drillDownOrder = null; }
    save(); renderTable(); renderHistory();
    $('#room-dialog').close();
    if (_roomDialogFromManager) openRoomManager();
    _roomDialogFromManager = false;
  }
});

// â”€â”€ Settings Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$('#btn-settings').addEventListener('click', () => {
  $('#settings-past-days').value = DATA.settings.pastDays ?? 3;
  $('#settings-future-days').value = DATA.settings.futureDays ?? 10;
  $('#settings-history-days').value = DATA.settings.historyDays;
  $('#settings-theme').value = DATA.settings.theme || 'dark';
  $('#settings-palette').value = DATA.settings.palette || 'blue-brown';
  $('#settings-api-url').value = DATA.settings.apiUrl || '';
  // Show auto-detected URL as placeholder when no explicit URL is set
  const autoUrl = (!DATA.settings.apiUrl && (location.protocol === 'http:' || location.protocol === 'https:')) ? location.origin + ' (auto-detected)' : 'e.g. http://192.168.1.50:8780';
  $('#settings-api-url').placeholder = autoUrl;
  renderSettingsUsers();
  // Show version
  updateVersionDisplay();
  $('#settings-dialog').showModal();
});
$('#settings-check-update').addEventListener('click', async () => {
  const btn = $('#settings-check-update');
  btn.disabled = true;
  btn.textContent = 'Checkingâ€¦';
  try {
    // Force the SW to check for a new version
    const reg = await navigator.serviceWorker?.getRegistration();
    if (reg) await reg.update();
    // Reload to pick up new SW / HTML
    location.reload();
  } catch {
    btn.textContent = 'Reload failed';
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Check for updates'; }, 2000);
  }
});
function updateVersionDisplay() {
  const verEl = $('#settings-version-text');
  const apiUrl = getApiUrl();
  if (apiUrl) {
    verEl.textContent = 'loadingâ€¦';
    fetch(apiUrl + '/version').then(r => r.json()).then(d => {
      verEl.textContent = 'server: ' + (d.version || '?') + ' Â· sw: ' + (navigator.serviceWorker?.controller ? 'active' : 'none');
    }).catch(() => { verEl.textContent = 'version: unavailable'; });
  } else {
    verEl.textContent = 'local-only Â· sw: ' + (navigator.serviceWorker?.controller ? 'active' : 'none');
  }
}
$('#settings-close').addEventListener('click', () => $('#settings-dialog').close());
$('#settings-save').addEventListener('click', async () => {
  DATA.settings.pastDays = Math.max(0, parseInt($('#settings-past-days').value) || 3);
  DATA.settings.futureDays = Math.max(1, parseInt($('#settings-future-days').value) || 10);
  DATA.settings.historyDays = Math.max(7, parseInt($('#settings-history-days').value) || 30);
  DATA.settings.theme = $('#settings-theme').value;
  DATA.settings.palette = $('#settings-palette').value;
  const newApiUrl = $('#settings-api-url').value.trim().replace(/\/+$/, '');
  const apiChanged = newApiUrl !== (DATA.settings.apiUrl || '');
  DATA.settings.apiUrl = newApiUrl || undefined;
  applyTheme();
  save(); renderTable(); renderHistory();
  if (apiChanged) {
    if (_ws) { _ws.close(); _ws = null; }
    await syncInit();
    renderTable(); renderUsers(); renderHistory();
  }
  $('#settings-dialog').close();
});
$('#settings-export').addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(DATA, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'chore-tracker-backup.json';
  a.click();
});
$('#settings-import').addEventListener('click', () => $('#settings-import-file').click());
$('#settings-import-file').addEventListener('change', e => {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const imported = JSON.parse(reader.result);
      if (imported.rooms && imported.entries) {
        DATA = imported;
        for (const room of DATA.rooms) { if (!room.tasks) room.tasks = []; }
        applyTheme();
        save(); renderTable(); renderUsers(); renderSettingsUsers(); renderHistory();
        $('#settings-dialog').close();
      } else { alert('Invalid backup file.'); }
    } catch { alert('Could not parse file.'); }
  };
  reader.readAsText(file);
  e.target.value = '';
});
$('#settings-reset').addEventListener('click', () => {
  if (confirm('Erase ALL data and start fresh? This cannot be undone.')) {
    DATA = defaultData();
    drillDown = null; drillDownOrder = null; viewMode = 'room';
    applyTheme();
    save(); renderTable(); renderUsers(); renderSettingsUsers(); renderHistory(); updateViewToggle();
    $('#settings-dialog').close();
  }
});

// â”€â”€ Users â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderUsers() {
  const list = $('#user-list');
  list.innerHTML = DATA.users.map(u =>
    `<span class="user-chip${DATA.selectedUser === u ? ' selected' : ''}" data-user="${esc(u)}">${esc(u)}</span>`
  ).join('');
}
$('#user-list').addEventListener('click', e => {
  const chip = e.target.closest('.user-chip');
  if (chip) {
    const name = chip.dataset.user;
    DATA.selectedUser = DATA.selectedUser === name ? null : name;
    save(); renderUsers();
  }
});
function renderSettingsUsers() {
  const list = $('#settings-user-list');
  list.innerHTML = DATA.users.map(u =>
    `<span class="user-chip" data-user="${esc(u)}">${esc(u)}<span class="remove-user" data-remove="${esc(u)}">âœ•</span></span>`
  ).join('');
}
$('#settings-user-list').addEventListener('click', e => {
  const remove = e.target.closest('.remove-user');
  if (remove) {
    const name = remove.dataset.remove;
    if (confirm(`Remove user "${name}"?`)) {
      DATA.users = DATA.users.filter(u => u !== name);
      if (DATA.selectedUser === name) DATA.selectedUser = null;
      save(); renderUsers(); renderSettingsUsers();
    }
  }
});
function addUser() {
  const input = $('#new-user-input');
  const name = input.value.trim();
  if (!name || DATA.users.includes(name)) return;
  DATA.users.push(name);
  DATA.selectedUser = name;
  input.value = '';
  save(); renderUsers(); renderSettingsUsers();
}
$('#btn-add-user').addEventListener('click', addUser);
$('#new-user-input').addEventListener('keydown', e => { if (e.key === 'Enter') addUser(); });

// â”€â”€ History Chart (canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function computeHistory() {
  const days = DATA.settings.historyDays || 30;
  const t = today();
  const result = [];
  for (let i = days - 1; i >= 0; i--) {
    const d = addDays(t, -i);
    let clean = 0, overdue = 0;
    for (const room of DATA.rooms) {
      if (roomHasTasks(room)) {
        for (const task of room.tasks) {
          const info = taskCellInfo(room, task, d);
          if (info.state === 'cleaned' || info.ratio < 1) clean++;
          else overdue++;
        }
      } else {
        const s = cellInfo(room, d);
        if (s.state === 'cleaned' || s.state === 'clean') clean++;
        else if (s.state === 'overdue') overdue++;
      }
    }
    result.push({ date: d, clean, overdue });
  }
  return result;
}

function renderHistory() {
  const history = computeHistory();
  const canvas = $('#history-chart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;
  if (W < 10 || H < 5) return;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, W, H);

  let maxItems = 0;
  for (const room of DATA.rooms) maxItems += roomHasTasks(room) ? room.tasks.length : 1;
  maxItems = maxItems || 1;

  const pad = 1;
  const pts = history.map(h => h.clean / maxItems);
  const stepX = (W - pad * 2) / Math.max(pts.length - 1, 1);
  const yFor = v => pad + (1 - v) * (H - pad * 2);

  const cs = getComputedStyle(document.documentElement);
  const p = getPalette();
  const [cr, cg, cb] = p.clean;
  const [dr, dg, db] = p.dirty;
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  const fillAlpha0 = isDark ? 0.45 : 0.30;
  const fillAlpha1 = isDark ? 0.05 : 0.03;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, `rgba(${cr},${cg},${cb},${fillAlpha0})`);
  grad.addColorStop(1, `rgba(${cr},${cg},${cb},${fillAlpha1})`);
  ctx.beginPath();
  ctx.moveTo(pad, H);
  pts.forEach((v, i) => ctx.lineTo(pad + i * stepX, yFor(v)));
  ctx.lineTo(pad + (pts.length - 1) * stepX, H);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  ctx.beginPath();
  pts.forEach((v, i) => {
    const x = pad + i * stepX, y = yFor(v);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.strokeStyle = `rgb(${cr},${cg},${cb})`;
  ctx.lineWidth = 1.5;
  ctx.lineJoin = 'round';
  ctx.stroke();

  const optsRed = history.map(h => h.overdue / maxItems);
  ctx.beginPath();
  optsRed.forEach((v, i) => {
    const x = pad + i * stepX, y = H - pad - v * (H - pad * 2);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.strokeStyle = `rgb(${dr},${dg},${db})`;
  ctx.lineWidth = 1;
  ctx.stroke();

  const lastX = pad + (pts.length - 1) * stepX;
  const lastY = yFor(pts[pts.length - 1]);
  ctx.beginPath(); ctx.arc(lastX, lastY, 2.5, 0, Math.PI * 2);
  ctx.fillStyle = `rgb(${cr},${cg},${cb})`; ctx.fill();

  ctx.strokeStyle = cs.getPropertyValue('--spark-sun').trim();
  ctx.lineWidth = 1;
  history.forEach((h, i) => {
    const dow = new Date(h.date + 'T12:00:00').getDay();
    if (dow === 0) {
      const x = Math.round(pad + i * stepX) + 0.5;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
  });

  $('#history-label').textContent = `${DATA.settings.historyDays}-day History`;
  const last = history[history.length - 1];
  const totalClean = history.reduce((s, h) => s + h.clean, 0);
  const totalOverdue = history.reduce((s, h) => s + h.overdue, 0);
  $('#history-summary').textContent =
    `${last?.clean || 0}âœ“ ${last?.overdue || 0}âœ— Â· ${totalClean}/${totalClean + totalOverdue} task-days`;
}

// â”€â”€ Tooltip on hover/long-press â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$('#table-body').addEventListener('pointerover', e => {
  if (e.pointerType === 'touch') return;
  const td = e.target.closest('td');
  if (!td) { $('#cell-tooltip').style.display = 'none'; return; }

  let tip = '';

  // Task detail cell
  if (td.dataset.room && td.dataset.task && td.dataset.date) {
    const room = DATA.rooms.find(r => r.id === td.dataset.room);
    const task = room?.tasks?.find(t => t.id === td.dataset.task);
    if (!room || !task) return;
    const info = taskCellInfo(room, task, td.dataset.date);
    const user = taskCleanedBy(room.id, task.id, td.dataset.date);
    let stateLabel;
    if (info.state === 'cleaned') stateLabel = 'Cleaned today';
    else if (info.daysOverdue > 0) stateLabel = `Overdue by ${info.daysOverdue}d`;
    else if (info.daysSince > 0) stateLabel = `Clean (${info.daysSince}d ago, due in ${task.cleanDays - info.daysSince}d)`;
    else stateLabel = 'Not yet cleaned';
    if (info.future) stateLabel = 'Projected: ' + stateLabel;
    const actionHint = info.future ? '' : info.state === 'cleaned' ? '\nTap to unmark' : '\nTap to mark done';
    tip = room.name + ' â€º ' + task.label + ' â€” ' + dayLabel(td.dataset.date) + '\n' + stateLabel + (user ? '\nBy: ' + user : '') + actionHint;

  // Aggregate room cell
  } else if (td.dataset.aggregate === 'room' && td.dataset.room && td.dataset.date) {
    const room = DATA.rooms.find(r => r.id === td.dataset.room);
    if (!room) return;
    const info = roomAggCellInfo(room, td.dataset.date);
    tip = room.name + ' â€” ' + dayLabel(td.dataset.date) + '\n' + info.fraction + ' tasks clean\nTap to see tasks';

  // Aggregate task type cell
  } else if (td.dataset.aggregate === 'tasktype' && td.dataset.tasktype && td.dataset.date) {
    const info = taskTypeAggCellInfo(td.dataset.tasktype, td.dataset.date);
    const roomTasks = getRoomsForTaskType(td.dataset.tasktype);
    const isFuture = td.dataset.date > today();
    let actionHint;
    if (roomTasks.length === 1) {
      if (isFuture) actionHint = '';
      else {
        const si = taskCellInfo(roomTasks[0].room, roomTasks[0].task, td.dataset.date);
        actionHint = si.state === 'cleaned' ? '\nTap to unmark' : '\nTap to mark done';
      }
    } else { actionHint = '\nTap to see rooms'; }
    tip = td.dataset.tasktype + ' â€” ' + dayLabel(td.dataset.date) + '\n' + info.fraction + ' rooms clean' + actionHint;

  // Simple room cell
  } else if (td.dataset.room && td.dataset.date) {
    const room = DATA.rooms.find(r => r.id === td.dataset.room);
    if (!room) return;
    const info = cellInfo(room, td.dataset.date);
    const user = cleanedBy(room, td.dataset.date);
    let stateLabel;
    if (info.state === 'cleaned') stateLabel = 'Cleaned today';
    else if (info.daysOverdue > 0) stateLabel = `Overdue by ${info.daysOverdue}d`;
    else if (info.daysSince > 0) stateLabel = `Clean (${info.daysSince}d ago, due in ${room.cleanDays - info.daysSince}d)`;
    else stateLabel = 'Not yet cleaned';
    if (info.future) stateLabel = 'Projected: ' + stateLabel;
    const actionHint = info.future ? '' : info.state === 'cleaned' ? '\nTap to unmark' : '\nTap to mark done';
    tip = room.name + ' â€” ' + dayLabel(td.dataset.date) + '\n' + stateLabel + (user ? '\nBy: ' + user : '') + actionHint;
  }

  if (!tip) { $('#cell-tooltip').style.display = 'none'; return; }
  const tt = $('#cell-tooltip');
  tt.textContent = tip; tt.style.whiteSpace = 'pre-line';
  tt.style.display = 'block';
  tt.style.left = Math.min(e.clientX + 12, window.innerWidth - 210) + 'px';
  tt.style.top = (e.clientY + 12) + 'px';
});
$('#table-body').addEventListener('pointerleave', () => { $('#cell-tooltip').style.display = 'none'; });

// Footer tooltips
$('#table-foot').addEventListener('pointerover', e => {
  if (e.pointerType === 'touch') return;
  const el = e.target.closest('[data-foot-tip]');
  if (!el) { $('#cell-tooltip').style.display = 'none'; return; }
  const tt = $('#cell-tooltip');
  tt.textContent = el.dataset.footTip; tt.style.whiteSpace = 'pre-line';
  tt.style.display = 'block';
  tt.style.left = Math.min(e.clientX + 12, window.innerWidth - 210) + 'px';
  tt.style.top = (e.clientY - 60) + 'px';
});
$('#table-foot').addEventListener('pointerleave', () => { $('#cell-tooltip').style.display = 'none'; });

// â”€â”€ Garbage-collect old entries (> 120 days) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gc() {
  const cutoff = addDays(today(), -120);
  for (const d of Object.keys(DATA.entries)) {
    if (d < cutoff) delete DATA.entries[d];
  }
  save();
}

// â”€â”€ Theme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyTheme() {
  const theme = DATA.settings.theme || 'dark';
  document.documentElement.setAttribute('data-theme', theme);
  invalidateNeutralCache();
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load();
applyTheme();
gc();
renderTable();
renderUsers();
renderHistory();
updateViewToggle();

// Kick off remote sync (non-blocking â€” UI is already rendered from localStorage)
syncInit().then(() => { renderTable(); renderUsers(); renderHistory(); });

setInterval(async () => {
  if (getApiUrl()) {
    await syncPull();
  }
  renderTable(); renderHistory();
}, 60_000);
window.addEventListener('resize', () => { renderTable(); renderHistory(); });

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(() => {});
}

</script>
</body>
</html>